<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rooftop Simulator V3.0 - Real Physics</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* HUD PRO */
        #stats { 
            position: absolute; top: 20px; left: 20px; 
            background: linear-gradient(90deg, rgba(0,0,0,0.8), rgba(0,0,0,0)); 
            padding: 15px; border-left: 5px solid #00d2ff;
            color: white; font-weight: bold; font-family: monospace; font-size: 16px;
            text-shadow: 0 0 5px #00d2ff; pointer-events: auto;
        }

        /* Mira Central */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            border: 1px solid black;
        }

        /* Menu Interativo */
        #interaction-menu {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(10, 10, 15, 0.95); border: 2px solid #fff; padding: 40px; text-align: center;
            pointer-events: auto; z-index: 100; box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .btn {
            display: block; width: 250px; padding: 15px; margin: 20px auto; cursor: pointer;
            font-weight: bold; font-size: 18px; border: none; text-transform: uppercase;
        }
        .btn-pix { background: #00e676; color: #000; box-shadow: 0 0 15px #00e676; }
        .btn-list { background: #f50057; color: white; box-shadow: 0 0 15px #f50057; }

        /* Instru√ß√µes */
        #instructions {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: white; font-size: 14px; text-shadow: 1px 1px 2px black;
        }
        
        #mobile-controls { display: none; pointer-events: auto; }
        .control-pad { position: absolute; bottom: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #stick-left { left: 30px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="stats">
            <div>üç∏ DRINKS: <span id="drink-count">0</span></div>
            <div>üé´ CONVITES: <span id="invites-count">0</span></div>
            <div>üí≤ CAIXA: R$ <span id="money-count">0</span></div>
        </div>
        
        <div id="interaction-menu">
            <h1 style="color:white; font-family: sans-serif; margin-bottom: 30px;">CONTROLE DE ACESSO</h1>
            <button class="btn btn-pix" onclick="processEntry('pix')">COBRAR PIX (R$ 50)</button>
            <button class="btn btn-list" onclick="processEntry('lista')">LISTA VIP (Gr√°tis)</button>
        </div>

        <div id="instructions">Clique para capturar o mouse | WASD para andar | Espa√ßo Pular | Mouse olha</div>
    </div>

    <div id="mobile-controls">
        <div id="stick-left" class="control-pad"></div>
        <div style="position:absolute; bottom:50px; right:30px; width:80px; height:80px; background:rgba(255,255,255,0.2); border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;" onclick="playerVelocity.y = 15;">PULAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { Octree } from 'three/addons/math/Octree.js';
        import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        // --- SISTEMA DE TEXTURAS AVAN√áADO ---
        function createAdvancedTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            if (type === 'brick') {
                // Tijolos escuros
                ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,1024,1024);
                ctx.fillStyle = '#3a3a3a';
                const w = 120, h = 60;
                for(let y=0; y<1024; y+=h+4) {
                    const offset = (y/(h+4)) % 2 === 0 ? 0 : w/2;
                    for(let x=-w; x<1024; x+=w+4) {
                        ctx.fillRect(x+offset, y, w, h);
                    }
                }
            } else if (type === 'wood_floor') {
                // Assoalho de madeira nobre
                ctx.fillStyle = '#3e2723'; ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = '#1a100e'; ctx.lineWidth = 3;
                for(let i=0; i<1024; i+=80) {
                    ctx.fillStyle = (i%160===0)?'#4e342e':'#3e2723';
                    ctx.fillRect(0, i, 1024, 80);
                    ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(1024,i); ctx.stroke();
                }
            } else if (type === 'sign_rooftop') {
                // Letreiro Neon
                ctx.fillStyle = '#000'; ctx.fillRect(0,0,1024,256);
                ctx.shadowBlur = 20; ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#fff'; ctx.font = "bold 150px Arial"; ctx.textAlign = "center";
                ctx.fillText("ROOFTOP CLUB", 512, 170);
            } else if (type === 'sign_wc_h') {
                ctx.fillStyle = '#003366'; ctx.fillRect(0,0,512,512);
                ctx.fillStyle = '#fff'; ctx.font = "bold 200px Arial"; ctx.textAlign = "center";
                ctx.fillText("WC H", 256, 300);
            } else if (type === 'sign_wc_m') {
                ctx.fillStyle = '#660033'; ctx.fillRect(0,0,512,512);
                ctx.fillStyle = '#fff'; ctx.font = "bold 200px Arial"; ctx.textAlign = "center";
                ctx.fillText("WC M", 256, 300);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            if (type === 'brick' || type === 'wood_floor') tex.repeat.set(4, 4);
            return tex;
        }

        const texBrick = createAdvancedTexture('brick');
        const texWood = createAdvancedTexture('wood_floor');
        const texSignRooftop = createAdvancedTexture('sign_rooftop');
        const texWCH = createAdvancedTexture('sign_wc_h');
        const texWCM = createAdvancedTexture('sign_wc_m');

        // --- VARI√ÅVEIS PRINCIPAIS ---
        let camera, scene, renderer;
        const clock = new THREE.Clock();
        
        // F√çSICA (Octree + Capsule)
        const worldOctree = new Octree();
        const playerCollider = new Capsule( new THREE.Vector3( 0, 0.35, 0 ), new THREE.Vector3( 0, 1, 0 ), 0.35 );
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;
        const GRAVITY = 30;

        // Input
        const keyStates = {};
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);

        // Game Logic
        const npcs = [];
        const waitingLine = [];
        const gameState = { drinks: 0, invites: 0, money: 0 };
        const uiDrinks = document.getElementById('drink-count');
        const uiInvites = document.getElementById('invites-count');
        const uiMoney = document.getElementById('money-count');

        init();
        animate();

        function init() {
            // Setup Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 0, 40);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;
            document.body.appendChild(renderer.domElement);

            // Luzes
            const ambient = new THREE.HemisphereLight(0x444455, 0x111111, 0.4);
            scene.add(ambient);

            const spotLight = new THREE.SpotLight(0xffffaa, 500);
            spotLight.position.set(10, 20, 10);
            spotLight.angle = 1.0; spotLight.penumbra = 0.5; spotLight.castShadow = true;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);

            // --- CONSTRU√á√ÉO DO MUNDO (COLLIDERS) ---
            // Tudo que o player pode colidir vai aqui
            const levelGeometry = new THREE.Group();
            
            // 1. Ch√£o (Rua)
            const streetGeo = new THREE.BoxGeometry(100, 1, 100);
            const streetMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            const street = new THREE.Mesh(streetGeo, streetMat);
            street.position.y = -0.5;
            street.receiveShadow = true;
            levelGeometry.add(street);

            // 2. Cal√ßada
            const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(20, 0.2, 100), new THREE.MeshStandardMaterial({ color: 0x555555 }));
            sidewalk.position.set(10, 0.1, 0);
            sidewalk.receiveShadow = true;
            levelGeometry.add(sidewalk);

            // 3. Pr√©dio (Paredes Externas)
            const buildingMat = new THREE.MeshStandardMaterial({ map: texBrick, roughness: 0.6 });
            
            // Parede Fundo
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 30), buildingMat);
            w1.position.set(30, 4, 0); levelGeometry.add(w1);
            
            // Parede Esquerda
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(15, 8, 1), buildingMat);
            w2.position.set(22.5, 4, -15); levelGeometry.add(w2);
            
            // Parede Direita
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(15, 8, 1), buildingMat);
            w3.position.set(22.5, 4, 15); levelGeometry.add(w3);
            
            // Parede Frente (com buraco da porta) - Simplificado: duas partes
            const w4a = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 10), buildingMat);
            w4a.position.set(15, 4, -10); levelGeometry.add(w4a);
            const w4b = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 10), buildingMat);
            w4b.position.set(15, 4, 10); levelGeometry.add(w4b);
            // Viga em cima da porta
            const w4c = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 10), buildingMat);
            w4c.position.set(15, 6, 0); levelGeometry.add(w4c);

            // 4. Pisos Internos (T√©rreo e Rooftop)
            const floorMat = new THREE.MeshStandardMaterial({ map: texWood });
            const floor1 = new THREE.Mesh(new THREE.BoxGeometry(15, 0.2, 29), floorMat);
            floor1.position.set(22.5, 0.1, 0); levelGeometry.add(floor1);

            const floor2 = new THREE.Mesh(new THREE.BoxGeometry(15, 0.2, 29), floorMat);
            floor2.position.set(22.5, 4.5, 0); levelGeometry.add(floor2);

            // 5. Escadas/Rampa F√≠sica
            // Em vez de box, usamos geometria inclinada para a c√°psula subir liso
            const rampGeo = new THREE.BoxGeometry(3, 0.5, 12);
            const ramp = new THREE.Mesh(rampGeo, new THREE.MeshStandardMaterial({color: 0x333333}));
            ramp.position.set(18, 2.25, 8); // Ajuste fino da posi√ß√£o
            ramp.rotation.x = -0.4; // Inclina√ß√£o calculada para alcan√ßar o andar
            levelGeometry.add(ramp);

            // 6. Banheiros (Paredes internas)
            const wcWall1 = new THREE.Mesh(new THREE.BoxGeometry(5, 4, 0.2), buildingMat);
            wcWall1.position.set(27, 2, 8); levelGeometry.add(wcWall1);
            const wcWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 5), buildingMat);
            wcWall2.position.set(24.5, 2, 10.5); levelGeometry.add(wcWall2);

            // ADICIONAR AO MUNDO DE COLIS√ÉO
            scene.add(levelGeometry);
            worldOctree.fromGraphNode(levelGeometry);

            // --- DETALHES VISUAIS (N√ÉO F√çSICOS OU SEPARADOS) ---
            
            // Letreiro Rooftop
            const signPlane = new THREE.Mesh(new THREE.PlaneGeometry(8, 2), new THREE.MeshBasicMaterial({ map: texSignRooftop, transparent: true }));
            signPlane.position.set(14.4, 6, 0);
            signPlane.rotation.y = -Math.PI / 2;
            scene.add(signPlane);
            const signLight = new THREE.PointLight(0xff00ff, 5, 10);
            signLight.position.set(14, 6, 0);
            scene.add(signLight);

            // Placas WC
            createSign(new THREE.Vector3(26, 3, 7.9), texWCH);
            createSign(new THREE.Vector3(28, 3, 7.9), texWCM);

            // ESPELHO NO BANHEIRO
            const mirrorGeo = new THREE.PlaneGeometry(2, 1.5);
            const mirror = new Reflector(mirrorGeo, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0x777777
            });
            mirror.position.set(29.4, 2.5, 10.5);
            mirror.rotation.y = -Math.PI / 2;
            scene.add(mirror);
            // Moldura do espelho
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.6, 2.1), new THREE.MeshStandardMaterial({color: 0xc0c0c0}));
            frame.position.set(29.45, 2.5, 10.5);
            scene.add(frame);

            // Decora√ß√£o da Balada
            setupPartyLights(new THREE.Vector3(22, 1, -8), 0xff0000); // T√©rreo
            setupPartyLights(new THREE.Vector3(22, 5, -8), 0x0000ff); // Rooftop

            // Inputs
            document.addEventListener('keydown', (e) => { keyStates[e.code] = true; });
            document.addEventListener('keyup', (e) => { keyStates[e.code] = false; });
            
            document.addEventListener('mousedown', () => {
                if(document.getElementById('interaction-menu').style.display !== 'block') {
                    document.body.requestPointerLock();
                }
            });
            
            document.body.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === document.body) {
                    camera.rotation.y -= event.movementX / 500;
                    camera.rotation.x -= event.movementY / 500;
                }
            });

            if (isMobile) setupMobileControls();

            // Spawn Inicial
            for(let i=0; i<15; i++) spawnNPC();
            
            window.addEventListener('resize', onWindowResize);
        }

        function createSign(pos, map) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), new THREE.MeshBasicMaterial({map:map}));
            mesh.position.copy(pos);
            scene.add(mesh);
        }

        function setupPartyLights(pos, color) {
            const bulb = new THREE.PointLight(color, 2, 15);
            bulb.position.set(pos.x, pos.y+2, pos.z);
            bulb.userData = { type: 'pulse' };
            scene.add(bulb);
            
            // Fuma√ßa volum√©trica falsa (Sprites)
            const pGeo = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<50; i++) positions.push((Math.random()-0.5)*5, Math.random()*3, (Math.random()-0.5)*5);
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const pMat = new THREE.PointsMaterial({color:color, size:0.3, transparent:true, opacity:0.3, blending: THREE.AdditiveBlending});
            const parts = new THREE.Points(pGeo, pMat);
            parts.position.copy(pos);
            scene.add(parts);
        }

        // --- L√ìGICA DE F√çSICA DO JOGADOR ---
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }

        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            if (!playerOnFloor) {
                playerVelocity.y -= GRAVITY * deltaTime;
                damping *= 0.1; // Menos atrito no ar
            }

            playerVelocity.addScaledVector(playerVelocity, damping);

            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            
            playerCollisions();
            
            camera.position.copy(playerCollider.end);
        }

        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }

        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        function controls(deltaTime) {
            const speed = playerOnFloor ? 15 : 8; // Velocidade de caminhada

            if (keyStates['KeyW']) playerVelocity.add(getForwardVector().multiplyScalar(speed * deltaTime));
            if (keyStates['KeyS']) playerVelocity.add(getForwardVector().multiplyScalar(-speed * deltaTime));
            if (keyStates['KeyA']) playerVelocity.add(getSideVector().multiplyScalar(-speed * deltaTime));
            if (keyStates['KeyD']) playerVelocity.add(getSideVector().multiplyScalar(speed * deltaTime));
            if (keyStates['Space'] && playerOnFloor) playerVelocity.y = 10; // Pulo
            
            // Intera√ß√£o
            if (keyStates['KeyE']) checkInteraction();

            // Mobile Inputs
            if (isMobile && mobileMoveForward) playerVelocity.add(getForwardVector().multiplyScalar(speed * deltaTime));
        }

        // --- L√ìGICA DO JOGO (NPCs) ---
        function spawnNPC() {
            // Placeholder para NPCs (Billboarding colorido)
            // Em uma vers√£o final voc√™ carregaria PNGs reais aqui
            const canvas = document.createElement('canvas');
            canvas.width=128; canvas.height=256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = `hsl(${Math.random()*360}, 70%, 50%)`;
            ctx.fillRect(20, 50, 88, 150); // Corpo
            ctx.beginPath(); ctx.arc(64, 40, 30, 0, Math.PI*2); ctx.fill(); // Cabe√ßa
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({map:tex});
            const sprite = new THREE.Sprite(mat);
            
            sprite.scale.set(1, 1.8, 1);
            // Spawnar na rua aleatoriamente
            sprite.position.set(
                Math.random() * -30, 
                0.9, 
                (Math.random() - 0.5) * 60
            );
            
            sprite.userData = { state: 'street', waitTime: 0, hasInvite: false, id: Math.random() };
            scene.add(sprite);
            npcs.push(sprite);
        }

        function updateNPCs(dt, time) {
            npcs.forEach(npc => {
                // Anima√ß√£o de "pulo" ao andar
                if(npc.userData.state === 'street') {
                    npc.position.y = 0.9 + Math.sin(time*10 + npc.userData.id)*0.05;
                    npc.position.z += Math.sin(npc.userData.id)*0.02; // Andar aleat√≥rio
                    
                    if(camera.position.distanceTo(npc.position) < 2.5 && !npc.userData.hasInvite) {
                        // Vender convite
                        npc.userData.hasInvite = true;
                        gameState.invites++;
                        uiInvites.innerText = gameState.invites;
                        npc.userData.state = 'line';
                        waitingLine.push(npc);
                        
                        // Ir para a fila
                        const idx = waitingLine.length - 1;
                        npc.position.set(10, 0.9, 5 - (idx * 1.0));
                    }
                }
            });
        }
        
        // Intera√ß√£o
        const raycaster = new THREE.Raycaster();
        function checkInteraction() {
            if(waitingLine.length > 0) {
                if (camera.position.distanceTo(waitingLine[0].position) < 4) {
                    document.exitPointerLock();
                    document.getElementById('interaction-menu').style.display = 'block';
                }
            }
        }

        window.processEntry = function(type) {
            if (waitingLine.length === 0) return;
            const npc = waitingLine.shift();
            
            if(type === 'pix') {
                gameState.money += 50;
                uiMoney.innerText = gameState.money;
            }
            
            // NPC entra na balada
            npc.position.set(22 + (Math.random()-0.5)*5, 0.9, (Math.random()-0.5)*5);
            npc.userData.state = 'inside';
            
            // Reorganiza fila
            waitingLine.forEach((n, i) => n.position.z = 5 - (i * 1.0));
            
            document.getElementById('interaction-menu').style.display = 'none';
            document.body.requestPointerLock();
        }

        // --- LOOP ---
        let mobileMoveForward = false;
        function setupMobileControls() {
            const s = document.getElementById('stick-left');
            s.addEventListener('touchstart', (e)=>{ e.preventDefault(); mobileMoveForward=true; });
            s.addEventListener('touchend', (e)=>{ e.preventDefault(); mobileMoveForward=false; });
            document.addEventListener('touchmove', (e)=>{
                if(e.touches[0].clientX > window.innerWidth/2) {
                     camera.rotation.y -= e.touches[0].clientX * 0.0001; // Simplificado
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            const deltaTime = Math.min(0.05, clock.getDelta());
            const time = clock.getElapsedTime();

            controls(deltaTime);
            updatePlayer(deltaTime);
            updateNPCs(deltaTime, time);
            
            // Piscar luzes
            scene.traverse(o => {
                if(o.userData.type === 'pulse') o.intensity = 2 + Math.sin(time*10)*1;
            });

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
